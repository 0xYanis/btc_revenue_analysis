# -*- coding: utf-8 -*-
"""CryptoRecommender.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16KKxtnwPxpDhxOTNSMFW3SlcGDbU34Jq
"""

pip install pmdarima

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from pmdarima.arima import auto_arima

def adf_test(df):
    test = adfuller(df)
    print('adf: ', test[0])
    print('p-value: ', test[1])
    print('Critical values: ', test[4])
    if test[0] > test[4]['5%']:
        print('Ряд не стационарен')
    else:
        print('Ряд стационарен')

#MSE & R2
def mseAndR2(y_actual, y_smoothed):
    n = len(y_actual)
    mse = ((y_actual - y_smoothed)**2).mean()
    y_mean = y_actual.mean()
    ss_total = ((y_actual - y_mean)**2).sum()
    ss_residual = ((y_actual - y_smoothed)**2).sum()
    r_squared = 1 - (ss_residual / ss_total)

    return mse, r_squared

#AKF
def akf(series, lag):
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))
    plot_acf(series, lags=lag, ax=ax1)
    plot_pacf(series, lags=lag, ax=ax2)
    plt.show()

#Components plot
def plot_сomponents(dataframe, seasonal_period):
    result = seasonal_decompose(dataframe, model='additive', period=seasonal_period)
    plt.figure(figsize=(12, 7))
    plt.subplot(411)
    plt.plot(result.observed, label='Доходность')
    plt.legend()
    plt.subplot(412)
    plt.plot(result.trend, label='Тренд')
    plt.legend()
    plt.subplot(413)
    plt.plot(result.seasonal, label='Сезонность')
    plt.legend()
    plt.subplot(414)
    plt.plot(result.resid, label='Остатки', marker='o')
    plt.legend()
    plt.show()

def metrics(real, forecast):

    if type(real)==pd.core.frame.DataFrame:
        real=real[real.columns[0]].values
    #real=np.array(real[real.columns[0]].values)
    forecast=np.array(forecast)
    print('MAD:', round(abs(real-forecast).mean(),4))
    print('MSE:', round(((real-forecast)**2).mean(),4))
    print('MAPE:', round((abs(real-forecast)/real).mean(),4))
    print('MPE:', round(((real-forecast)/real).mean(),4))
    print('Стандартная ошибка:', round(((real-forecast)**2).mean()**0.5,4))

btc_df = pd.read_csv('btc.csv', index_col=['date'], parse_dates=['date']).drop(labels=['difficulty','hash-rate', 'market-price', 'trade-volume'], axis=1)
revenue = btc_df['2023-01-01':'2023-12-31']
revenue.head()

revenue = revenue * 0.0000001
revenue = revenue
revenue.describe()

revenue.resample(rule='W').mean().diff().plot(figsize=(12,5))

adf_test(revenue)

adf_test(revenue.diff().dropna()) # дифференцированрие первого порядка

plot_сomponents(revenue, 30)

akf(revenue.resample(rule='W').mean(), 12)

data_to_forecast = revenue#.resample(rule='W').mean()

find_optimal_model = auto_arima(data_to_forecast, seasonal=True, m=12)
print(find_optimal_model.summary())

arima_model = ARIMA(data_to_forecast, order=(5,1,2), seasonal_order=(2,0,0,12))
arima_fit = arima_model.fit()
forecast = arima_fit.forecast(steps=65)

plt.figure(figsize=(12,6))
plt.plot(data_to_forecast, label='Исходные данные')
plt.plot(forecast, label='Прогноз')
plt.plot(arima_fit.fittedvalues, label='Модель', marker='.')
plt.legend()
plt.show()

forecast.describe()

metrics(data_to_forecast[300:], forecast)

"""Коэф Сортино"""

def minmax(series, new_min=-1, new_max=1):
    min_val = series.min()
    max_val = series.max()
    normalized_series = new_min + ((series - min_val) * (new_max - new_min)) / (max_val - min_val)
    return normalized_series

def sortino_ratio(returns, risk_free_rate=0, target=0):
    downside_returns = returns - target
    downside_returns = downside_returns[downside_returns < 0]
    expected_return = returns.mean()
    downside_deviation = np.sqrt((expected_return ** 2)).mean()
    sortino_ratio = (expected_return - risk_free_rate) / downside_deviation
    print(sortino_ratio)

import json

with open('coins.json', 'r') as file:
    data = json.load(file)

coins_data = []

for coin, details in data['coins'].items():
    coin_name = coin
    coin_revenue = details.get('btc_revenue', None)
    coins_data.append({'coin': coin_name, 'revenue': coin_revenue})

df_coins = pd.DataFrame(coins_data)
df_coins[:6].sort_values(by='revenue', ascending=False)

coin_list = []
for index, row in df_coins.iterrows():
    coin_name = row['coin']
    coin_revenue = row['revenue']
    ratio = sortino_ratio(coin_revenue)
    coin_list.append({'coin': coin_name, 'sortino': ratio})

print(coin_list.sort_values(by='revenue', ascending=False))